package vn.id.tozydev.phantom.gradle.paper.features.plugin

import com.palantir.javapoet.AnnotationSpec
import com.palantir.javapoet.ClassName
import com.palantir.javapoet.CodeBlock
import com.palantir.javapoet.FieldSpec
import com.palantir.javapoet.JavaFile
import com.palantir.javapoet.MethodSpec
import com.palantir.javapoet.ParameterSpec
import com.palantir.javapoet.ParameterizedTypeName
import com.palantir.javapoet.TypeSpec
import org.jetbrains.annotations.NotNull
import java.nio.file.Path
import java.time.LocalDateTime
import javax.annotation.processing.Generated
import javax.lang.model.element.Modifier

internal class DynamicLibrariesLoaderClassBuilder {
    var packageName: String = "vn.id.tozydev.paperinfra.paper"
    var className: String = "DynamicLibrariesPluginLoader"
    var repositories: Map<String, String> = mapOf()
    var dependencies: List<String> = listOf()

    fun writeToPath(directory: Path) {
        createJavaFile().writeToPath(directory)
    }

    private fun createJavaFile(): JavaFile =
        JavaFile
            .builder(packageName, createTypeSpec())
            .skipJavaLangImports(true)
            .build()

    private fun createTypeSpec(): TypeSpec =
        TypeSpec
            .classBuilder(className)
            .addModifiers(Modifier.PUBLIC)
            .addAnnotation(suppressUnstableApiUsageAnnotation)
            .addAnnotation(createGeneratedAnnotationSpec())
            .addSuperinterface(PluginLoader)
            .addField(repositoriesField)
            .addField(dependenciesField)
            .addStaticBlock(createStaticInitializer())
            .addMethod(classloaderMethod)
            .build()

    private val suppressUnstableApiUsageAnnotation =
        AnnotationSpec
            .builder(SuppressWarnings::class.java)
            .addMember("value", $$"$S", "UnstableApiUsage")
            .build()

    private fun createGeneratedAnnotationSpec() =
        AnnotationSpec
            .builder(Generated::class.java)
            .addMember("value", $$"$S", DynamicLibrariesLoaderClassBuilder::class.qualifiedName)
            .addMember("date", $$"$S", LocalDateTime.now().toString())
            .addMember("comments", $$"$S", "Generated by vn.id.tozydev.paperinfra.paper Gradle plugin")
            .build()

    private fun createStaticInitializer(): CodeBlock =
        CodeBlock
            .builder()
            .apply {
                for ((key, value) in repositories) {
                    addStatement($$"repositories.put($S, $S)", key, value)
                }
                for (dependency in dependencies) {
                    addStatement($$"dependencies.add($S)", dependency)
                }
            }.build()

    private val repositoriesField: FieldSpec
        get() {
            val mapOfStringString =
                ParameterizedTypeName.get(
                    ClassName.get(MutableMap::class.java),
                    ClassName.get(String::class.java),
                    ClassName.get(String::class.java),
                )

            return FieldSpec
                .builder(mapOfStringString, "repositories")
                .addModifiers(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)
                .initializer($$"new $T<>()", ClassName.get(LinkedHashMap::class.java))
                .build()
        }

    private val dependenciesField: FieldSpec
        get() {
            val listOfString =
                ParameterizedTypeName.get(
                    ClassName.get(MutableList::class.java),
                    ClassName.get(String::class.java),
                )

            return FieldSpec
                .builder(listOfString, "dependencies")
                .addModifiers(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)
                .initializer($$"new $T<>()", ClassName.get(ArrayList::class.java))
                .build()
        }

    private val classloaderMethod: MethodSpec
        get() {
            return MethodSpec
                .methodBuilder("classloader")
                .addAnnotation(Override::class.java)
                .addModifiers(Modifier.PUBLIC)
                .addParameter(
                    ParameterSpec
                        .builder(PluginClasspathBuilder, "pluginClasspathBuilder")
                        .addAnnotation(NotNull::class.java)
                        .build(),
                ).addCode(
                    CodeBlock
                        .builder()
                        .addStatement($$"var resolver = new $T()", MavenLibraryResolver)
                        .beginControlFlow("for (var entry : repositories.entrySet())")
                        .addStatement(
                            $$"resolver.addRepository(new $T.Builder(entry.getKey(), $S, entry.getValue()).build())",
                            RemoteRepository,
                            "default",
                        ).endControlFlow()
                        .beginControlFlow("for (String dependency : dependencies)")
                        .addStatement(
                            $$"resolver.addDependency(new $T(new $T(dependency), null))",
                            Dependency,
                            DefaultArtifact,
                        ).endControlFlow()
                        .addStatement("pluginClasspathBuilder.addLibrary(resolver)")
                        .build(),
                ).build()
        }

    companion object {
        private val PluginLoader = ClassName.get("io.papermc.paper.plugin.loader", "PluginLoader")
        private val PluginClasspathBuilder =
            ClassName.get("io.papermc.paper.plugin.loader", "PluginClasspathBuilder")
        private val MavenLibraryResolver =
            ClassName.get("io.papermc.paper.plugin.loader.library.impl", "MavenLibraryResolver")
        private val RemoteRepository = ClassName.get("org.eclipse.aether.repository", "RemoteRepository")
        private val Dependency = ClassName.get("org.eclipse.aether.graph", "Dependency")
        private val DefaultArtifact = ClassName.get("org.eclipse.aether.artifact", "DefaultArtifact")
    }
}
